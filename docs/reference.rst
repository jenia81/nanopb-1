=====================
Nanopb: API reference
=====================

.. include :: menu.rst

.. contents ::

pb.h
====

pb_type_t
---------
Defines the encoder/decoder behaviour that should be used for a field. ::

    typedef enum { ... } pb_type_t;

The low-order byte of the enumeration values defines the function that can be used for encoding and decoding the field data:

==================== ===== ================================================
LTYPE identifier     Value Storage format
==================== ===== ================================================
PB_LTYPE_VARINT      0x00  Integer.
PB_LTYPE_SVARINT     0x01  Integer, zigzag encoded.
PB_LTYPE_FIXED       0x02  Integer or floating point.
PB_LTYPE_BYTES       0x03  Structure with *size_t* field and byte array.
PB_LTYPE_STRING      0x04  Null-terminated string.
PB_LTYPE_SUBMESSAGE  0x05  Submessage structure.
==================== ===== ================================================

The high-order byte defines whether the field is required, optional, repeated or callback:

==================== ===== ================================================
HTYPE identifier     Value Field handling
==================== ===== ================================================
PB_HTYPE_REQUIRED    0x00  Verify that field exists in decoded message.
PB_HTYPE_OPTIONAL    0x10  Use separate *has_<field>* boolean to specify
                           whether the field is present.
PB_HTYPE_ARRAY       0x20  A repeated field with preallocated array.
                           Separate *<field>_count* for number of items.
PB_HTYPE_CALLBACK    0x30  A field with dynamic storage size, data is
                           actually a pointer to a structure containing a
                           callback function.
==================== ===== ================================================

pb_field_t
----------
Describes a single structure field with memory position in relation to others. The descriptions are usually autogenerated. ::

    typedef struct _pb_field_t pb_field_t;
    struct _pb_field_t {
        uint8_t tag;
        pb_type_t type;
        uint8_t data_offset;
        int8_t size_offset;
        uint8_t data_size;
        uint8_t array_size;
        const void *ptr;
    } pb_packed;

:tag:           Tag number of the field or 0 to terminate a list of fields.
:type:          LTYPE and HTYPE of the field.
:data_offset:   Offset of field data, relative to the end of the previous field.
:size_offset:   Offset of *bool* flag for optional fields or *size_t* count for arrays, relative to field data.
:data_size:     Size of a single data entry, in bytes. For PB_LTYPE_BYTES, the size of the byte array inside the containing structure. For PB_HTYPE_CALLBACK, size of the C data type if known.
:array_size:    Maximum number of entries in an array, if it is an array type.
:ptr:           Pointer to default value for optional fields, or to submessage description for PB_LTYPE_SUBMESSAGE.

The *uint8_t* datatypes limit the maximum size of a single item to 255 bytes and arrays to 255 items. Compiler will warn "Initializer too large for type" if the limits are exceeded. The types can be changed to larger ones if necessary.

pb_bytes_array_t
----------------
An byte array with a field for storing the length::

    typedef struct {
        size_t size;
        uint8_t bytes[1];
    } pb_bytes_array_t;

In an actual array, the length of *bytes* may be different.

pb_callback_t
-------------
Part of a message structure, for fields with type PB_HTYPE_CALLBACK::

    typedef struct _pb_callback_t pb_callback_t;
    struct _pb_callback_t {
        union {
            bool (*decode)(pb_istream_t *stream, const pb_field_t *field, void *arg);
            bool (*encode)(pb_ostream_t *stream, const pb_field_t *field, const void *arg);
        } funcs;
        
        void *arg;
    };

The *arg* is passed to the callback when calling. It can be used to store any information that the callback might need.

When calling `pb_encode`_, *funcs.encode* is used, and similarly when calling `pb_decode`_, *funcs.decode* is used. The function pointers are stored in the same memory location but are of incompatible types. You can set the function pointer to NULL to skip the field.

pb_wire_type_t
--------------
Protocol Buffers wire types. These are used with `pb_encode_tag`_. ::

    typedef enum {
        PB_WT_VARINT = 0,
        PB_WT_64BIT  = 1,
        PB_WT_STRING = 2,
        PB_WT_32BIT  = 5
    } pb_wire_type_t;

pb_encode.h
===========

pb_ostream_from_buffer
----------------------
Constructs an output stream for writing into a memory buffer. This is just a helper function, it doesn't do anything you couldn't do yourself in a callback function. It uses an internal callback that stores the pointer in stream *state* field. ::

    pb_ostream_t pb_ostream_from_buffer(uint8_t *buf, size_t bufsize);

:buf:           Memory buffer to write into.
:bufsize:       Maximum number of bytes to write.
:returns:       An output stream.

After writing, you can check *stream.bytes_written* to find out how much valid data there is in the buffer.

pb_write
--------
Writes data to an output stream. Always use this function, instead of trying to call stream callback manually. ::

    bool pb_write(pb_ostream_t *stream, const uint8_t *buf, size_t count);

:stream:        Output stream to write to.
:buf:           Pointer to buffer with the data to be written.
:count:         Number of bytes to write.
:returns:       True on success, false if maximum length is exceeded or an IO error happens.

If an error happens, *bytes_written* is not incremented. Depending on the callback used, calling pb_write again after it has failed once may be dangerous. Nanopb itself never does this, instead it returns the error to user application. The builtin pb_ostream_from_buffer is safe to call again after failed write.

pb_encode
---------
Encodes the contents of a structure as a protocol buffers message and writes it to output stream. ::

    bool pb_encode(pb_ostream_t *stream, const pb_field_t fields[], const void *src_struct);

:stream:        Output stream to write to.
:fields:        A field description array, usually autogenerated.
:src_struct:    Pointer to the data that will be serialized.
:returns:       True on success, false on IO error, on detectable errors in field description, or if a field encoder returns false.

Normally pb_encode simply walks through the fields description array and serializes each field in turn. However, submessages must be serialized twice: first to calculate their size and then to actually write them to output. This causes some constraints for callback fields, which must return the same data on every call.

pb_encode_varint
----------------
Encodes an unsigned integer in the varint_ format. ::

    bool pb_encode_varint(pb_ostream_t *stream, uint64_t value);

:stream:        Output stream to write to. 1-10 bytes will be written.
:value:         Value to encode.
:returns:       True on success, false on IO error.

.. _varint: http://code.google.com/apis/protocolbuffers/docs/encoding.html#varints

pb_encode_tag
-------------
Starts a field in the Protocol Buffers binary format: encodes the field number and the wire type of the data. ::

    bool pb_encode_tag(pb_ostream_t *stream, pb_wire_type_t wiretype, int field_number);

:stream:        Output stream to write to. 1-5 bytes will be written.
:wiretype:      PB_WT_VARINT, PB_WT_64BIT, PB_WT_STRING or PB_WT_32BIT
:field_number:  Identifier for the field, defined in the .proto file.
:returns:       True on success, false on IO error.

pb_encode_tag_for_field
-----------------------
Same as `pb_encode_tag`_, except takes the parameters from a *pb_field_t* structure. ::

    bool pb_encode_tag_for_field(pb_ostream_t *stream, const pb_field_t *field);

:stream:        Output stream to write to. 1-5 bytes will be written.
:field:         Field description structure. Usually autogenerated.
:returns:       True on success, false on IO error or unknown field type.

This function only considers the LTYPE of the field. You can use it from your field callbacks, because the source generator writes correct LTYPE also for callback type fields.

Wire type mapping is as follows:

========================= ============
LTYPEs                    Wire type
========================= ============
VARINT, SVARINT           PB_WT_VARINT
FIXED64                   PB_WT_64BIT  
STRING, BYTES, SUBMESSAGE PB_WT_STRING 
FIXED32                   PB_WT_32BIT
========================= ============

pb_encode_string
----------------
Writes the length of a string as varint and then contents of the string. Used for writing fields with wire type PB_WT_STRING. ::

    bool pb_encode_string(pb_ostream_t *stream, const uint8_t *buffer, size_t size);

:stream:        Output stream to write to.
:buffer:        Pointer to string data.
:size:          Number of bytes in the string.
:returns:       True on success, false on IO error.

.. sidebar:: Field encoders

    The functions with names beginning with *pb_enc_* are called field encoders. Each PB_LTYPE has an own field encoder, which handles translating from C data into Protocol Buffers data.

    By using the *data_size* in the field description and by taking advantage of C casting rules, it has been possible to combine many data types to a single LTYPE. For example, *int32*, *uint32*, *int64*, *uint64*, *bool* and *enum* are all handled by *pb_enc_varint*.

    Each field encoder only encodes the contents of the field. The tag must be encoded separately with `pb_encode_tag_for_field`_.

    You can use the field encoders from your callbacks. Just be aware that the pb_field_t passed to the callback is not directly compatible with most of the encoders. Instead, you must create a new pb_field_t structure and set the data_size according to the data type you pass to *src*.

pb_enc_varint
-------------
Field encoder for PB_LTYPE_VARINT. Takes the first *field->data_size* bytes from src, casts them as *uint64_t* and calls `pb_encode_varint`_. ::

    bool pb_enc_varint(pb_ostream_t *stream, const pb_field_t *field, const void *src);

:stream:        Output stream to write to.
:field:         Field description structure. Only *data_size* matters.
:src:           Pointer to start of the field data.
:returns:       True on success, false on IO error.

pb_enc_svarint
--------------
Field encoder for PB_LTYPE_SVARINT. Similar to `pb_enc_varint`_, except first zig-zag encodes the value for more efficient negative number encoding. ::

    bool pb_enc_svarint(pb_ostream_t *stream, const pb_field_t *field, const void *src);

(parameters are the same as for `pb_enc_varint`_)

The number is considered negative if the high-order bit of the value is set. On big endian computers, it is the highest bit of *\*src*. On little endian computers, it is the highest bit of *\*(src + field->data_size - 1)*.

pb_enc_fixed32
--------------
Field encoder for PB_LTYPE_FIXED32. Writes the data in little endian order. On big endian computers, reverses the order of bytes. ::

    bool pb_enc_fixed32(pb_ostream_t *stream, const pb_field_t *field, const void *src);

:stream:        Output stream to write to.
:field:         Not used.
:src:           Pointer to start of the field data.
:returns:       True on success, false on IO error.

pb_enc_fixed64
--------------
Field encoder for PB_LTYPE_FIXED64. Writes the data in little endian order. On big endian computers, reverses the order of bytes. ::

    bool pb_enc_fixed64(pb_ostream_t *stream, const pb_field_t *field, const void *src);

(parameters are the same as for `pb_enc_fixed32`_)

The same function is used for both integers and doubles. This breaks encoding of double values on architectures where they are mixed endian (primarily some arm processors with hardware FPU).

pb_enc_bytes
------------
Field encoder for PB_LTYPE_BYTES. Just calls `pb_encode_string`_. ::

    bool pb_enc_bytes(pb_ostream_t *stream, const pb_field_t *field, const void *src);

:stream:        Output stream to write to.
:field:         Not used.
:src:           Pointer to a structure similar to pb_bytes_array_t.
:returns:       True on success, false on IO error.

This function expects a pointer to a structure with a *size_t* field at start, and a variable sized byte array after it. The platform-specific field offset is inferred from *pb_bytes_array_t*, which has a byte array of size 1.

pb_enc_string
-------------
Field encoder for PB_LTYPE_STRING. Determines size of string with strlen() and then calls `pb_encode_string`_. ::

    bool pb_enc_string(pb_ostream_t *stream, const pb_field_t *field, const void *src);

:stream:        Output stream to write to.
:field:         Not used.
:src:           Pointer to a null-terminated string.
:returns:       True on success, false on IO error.

pb_enc_submessage
-----------------
Field encoder for PB_LTYPE_SUBMESSAGE. Calls `pb_encode`_ to perform the actual encoding. ::

    bool pb_enc_submessage(pb_ostream_t *stream, const pb_field_t *field, const void *src);

:stream:        Output stream to write to.
:field:         Field description structure. The *ptr* field must be a pointer to a field description array for the submessage.
:src:           Pointer to the structure where submessage data is.
:returns:       True on success, false on IO errors, pb_encode errors or if submessage size changes between calls.

In Protocol Buffers format, the submessage size must be written before the submessage contents. Therefore, this function has to encode the submessage twice in order to know the size beforehand.

If the submessage contains callback fields, the callback function might misbehave and write out a different amount of data on the second call. This situation is recognized and *false* is returned, but it is up to the caller to ensure that the receiver of the message does not interpret it as valid data.

pb_decode.h
===========

pb_istream_from_buffer
----------------------
Helper function for creating an input stream that reads data from a memory buffer. ::

    pb_istream_t pb_istream_from_buffer(uint8_t *buf, size_t bufsize);

:buf:           Pointer to byte array to read from.
:bufsize:       Size of the byte array.
:returns:       An input stream ready to use.

pb_read
-------
Read data from input stream. Always use this function, don't try to call the stream callback directly. ::

    bool pb_read(pb_istream_t *stream, uint8_t *buf, size_t count);

:stream:        Input stream to read from.
:buf:           Buffer to store the data to, or NULL to just read data without storing it anywhere.
:count:         Number of bytes to read.
:returns:       True on success, false if *stream->bytes_left* is less than *count* or if an IO error occurs.

End of file is signalled by *stream->bytes_left* being zero after pb_read returns false.

pb_decode_varint
----------------
Read and decode a varint_ encoded integer. ::

    bool pb_decode_varint(pb_istream_t *stream, uint64_t *dest);

:stream:        Input stream to read from. 1-10 bytes will be read.
:dest:          Storage for the decoded integer. Value is undefined on error.
:returns:       True on success, false if value exceeds uint64_t range or an IO error happens.

pb_skip_varint
--------------
Skip a varint_ encoded integer without decoding it. ::

    bool pb_skip_varint(pb_istream_t *stream);

:stream:        Input stream to read from. Will read 1 byte at a time until the MSB is clear.
:returns:       True on success, false on IO error.

pb_skip_string
--------------
Skip a varint-length-prefixed string. This means skipping a value with wire type PB_WT_STRING. ::

    bool pb_skip_string(pb_istream_t *stream);

:stream:        Input stream to read from.
:returns:       True on success, false on IO error or length exceeding uint32_t.

pb_decode
---------
Read and decode all fields of a structure. Reads until EOF on input stream. ::

    bool pb_decode(pb_istream_t *stream, const pb_field_t fields[], void *dest_struct);

:stream:        Input stream to read from.
:fields:        A field description array. Usually autogenerated.
:dest_struct:   Pointer to structure where data will be stored.
:returns:       True on success, false on IO error, on detectable errors in field description, if a field encoder returns false or if a required field is missing.

In Protocol Buffers binary format, EOF is only allowed between fields. If it happens anywhere else, pb_decode will return *false*. If pb_decode returns false, you cannot trust any of the data in the structure.

In addition to EOF, the pb_decode implementation supports terminating a message with a 0 byte. This is compatible with the official Protocol Buffers because 0 is never a valid field tag.

For optional fields, this function applies the default value and sets *has_<field>* to false if the field is not present.

Because of memory concerns, the detection of missing required fields is not perfect if the structure contains more than 32 fields.

.. sidebar:: Field decoders
    
    The functions with names beginning with *pb_dec_* are called field decoders. Each PB_LTYPE has an own field decoder, which handles translating from Protocol Buffers data to C data.

    Each field decoder reads and decodes a single value. For arrays, the decoder is called repeatedly.

    You can use the decoders from your callbacks. Just be aware that the pb_field_t passed to the callback is not directly compatible with most of the field decoders. Instead, you must create a new pb_field_t structure and set the data_size according to the data type you pass to *dest*.

pb_dec_varint
-------------
Field decoder for PB_LTYPE_VARINT. ::

    bool pb_dec_varint(pb_istream_t *stream, const pb_field_t *field, void *dest)

:stream:        Input stream to read from. 1-10 bytes will be read.
:field:         Field description structure. Only *field->data_size* matters.
:dest:          Pointer to destination integer. Must have size of *field->data_size* bytes.
:returns:       True on success, false on IO errors or if `pb_decode_varint`_ fails.

This function first calls `pb_decode_varint`_. It then copies the first bytes of the 64-bit result value to *dest*, or on big endian architectures, the last bytes.

pb_dec_svarint
--------------
Field decoder for PB_LTYPE_SVARINT. Similar to `pb_dec_varint`_, except that it performs zigzag-decoding on the value. ::

    bool pb_dec_svarint(pb_istream_t *stream, const pb_field_t *field, void *dest);

(parameters are the same as `pb_dec_varint`_)

pb_dec_fixed32
--------------
Field decoder for PB_LTYPE_FIXED32. ::

    bool pb_dec_fixed(pb_istream_t *stream, const pb_field_t *field, void *dest);

:stream:        Input stream to read from. 1-10 bytes will be read.
:field:         Not used.
:dest:          Pointer to destination integer. Must have size of *field->data_size* bytes.
:returns:       True on success, false on IO errors or if `pb_decode_varint`_ fails.

This function reads 4 bytes from the input stream.
On big endian architectures, it then reverses the order of the bytes.
Finally, it writes the bytes to *dest*.

pb_dec_fixed64
--------------
Field decoder for PB_LTYPE_FIXED64. ::

    bool pb_dec_fixed(pb_istream_t *stream, const pb_field_t *field, void *dest);

Same as `pb_dec_fixed32`_, except this reads 8 bytes.

pb_dec_bytes
------------
Field decoder for PB_LTYPE_BYTES. Reads a length-prefixed block of bytes. ::

    bool pb_dec_bytes(pb_istream_t *stream, const pb_field_t *field, void *dest);

:stream:        Input stream to read from.
:field:         Field description structure. Only *field->data_size* matters.
:dest:          Pointer to a structure similar to pb_bytes_array_t.
:returns:       True on success, false on IO error or if length exceeds the array size.

This function expects a pointer to a structure with a *size_t* field at start, and a variable sized byte array after it. It will deduce the maximum size of the array from *field->data_size*.

pb_dec_string
-------------
Field decoder for PB_LTYPE_STRING. Reads a length-prefixed string. ::

    bool pb_dec_string(pb_istream_t *stream, const pb_field_t *field, void *dest);

:stream:        Input stream to read from.
:field:         Field description structure. Only *field->data_size* matters.
:dest:          Pointer to a character array of size *field->data_size*.
:returns:       True on success, false on IO error or if length exceeds the array size.

This function null-terminates the string when successful. On error, the contents of the destination array is undefined.

pb_dec_submessage
-----------------
Field decoder for PB_LTYPE_SUBMESSAGE. Calls `pb_decode`_ to perform the actual decoding. ::

    bool pb_dec_submessage(pb_istream_t *stream, const pb_field_t *field, void *dest)

:stream:        Input stream to read from.
:field:         Field description structure. Only *field->ptr* matters.
:dest:          Pointer to the destination structure.
:returns:       True on success, false on IO error or if `pb_decode`_ fails.

The *field->ptr* should be a pointer to *pb_field_t* array describing the submessage.

